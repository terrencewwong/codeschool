{
  "name": "Code School",
  "tagline": "Lesson 1 - Assignment",
  "body": "# Lesson 1 - Assignment\r\n\r\n## Fun with strings\r\n\r\n### Instructions\r\n\r\nDownload the starter code from [here](https://github.com/wongterrencew/codeschool/archive/master.zip)\r\n\r\nYou will find six files in the started code:\r\n\r\n```\r\n1. lesson1_task0.rb\r\n2. lesson1_task0_test.rb\r\n3. lesson1_task1.rb\r\n4. lesson1_task1_test.rb\r\n5. lesson1_task2.rb\r\n6. lesson1_task2_test.rb\r\n```\r\n\r\nThe code that you write should go in `lesson1_task*.rb`\r\n\r\nThe other files, `lesson1_task*_test.rb` are test files that should help you test if your code is correct.\r\n\r\nTo use the test files do the following in the terminal:\r\n\r\n```bash\r\n> ruby lesson1_task0_test.rb lesson1_task0.rb\r\n```\r\n\r\nYou should see output like the following:\r\n```\r\n✓ Test 1\r\n✗ Test 2\r\n  Expected: \"Stevie Wonder\"\r\n  Got: \"StevieWonder\"\r\n```\r\n\r\nIn this case `Expected` is the correct answer that we're expecting and `Got` is the incorrect answer that your solution produced.\r\n\r\n### Task 0: String concatenation\r\n\r\nIn class we talked about using variables inside of strings. The big fancy word for this is called \"string interpolation\", but in Typeform this is more commonly known as \"piping\".\r\n\r\nExample:\r\n\r\n```ruby\r\nfirst_name = \"Beardy\"\r\nlast_name = \"Man\"\r\n\r\nputs \"Hello, #{first_name} #{last_name}!\" # \"Hello, Beardy Man!\"\r\n```\r\n\r\nHowever... Ruby also allows you to use strings and variables together using \"string concatenation\". This is easiest shown with an example:\r\n\r\nExample:\r\n\r\n```ruby\r\nfirst_name = \"Beardy\"\r\nlast_name = \"Man\"\r\n\r\nputs \"Hello, \" + fist_name + \" \" + last_name + \"!\" # \"Hello, Beardy Man\"!\r\n```\r\n\r\nThe two examples above contain exactly the same output, but they're just written in different ways. Sometimes you may find it more convenient to use string interpolation and at other times you may find it more convenient to use string concatenation, in general there is no strict rule when to use either technique.\r\n\r\nIn this task you will write a method whose inputs are a first name and last name and whose output is the persons full name.\r\n\r\nExample:\r\n\r\n```ruby\r\nfull_name(\"Marvin\", \"Gaye\") # \"Marvin Gaye\"\r\nfull_name(\"Diana\", \"Ross\") # \"Diana Ross\"\r\n```\r\n\r\nHint: to define a function that accepts two arguments you use the following syntax\r\n\r\n```ruby\r\ndef method(arg1, arg2)\r\n  # code that does stuff would go here\r\nend\r\n```\r\n\r\nPlease upload a ruby file named `lesson1_task0.rb` containing the method `full_name`. Your code should use string concatenation and not string interpolation.\r\n\r\n### Task 1: A better `capitalize`\r\n\r\nRuby is a language with a lot of convenience methods, one of which is the string method `capitalize`. However... this method doesn't work on words that begin with an accented character :(\r\n\r\nTry the following in `irb`\r\n\r\n```\r\n> \"árbol\".capitalize\r\n```\r\n\r\nWhat do you expect the output to be? What is the actual output?\r\n\r\nIn this task you should write a method `spanish_capitalize` that can capitalize normal words as well as words that begin with an accented character.\r\n\r\nExample:\r\n\r\n```ruby\r\nspanish_capitalize(\"árbol\") # \"Árbol\"\r\nspanish_captialize(\"ése\") # \"Ése\"\r\nspanish_capitalize(\"typeform\") # \"Typeform\"\r\n```\r\n\r\nHint: You can find pull out parts of a string using square brackets. The first letter starts at 0, the second at 1, etc.\r\n\r\n```ruby\r\n\"Typeform\"[0] # \"T\"\r\n\"Typeform\"[1] # \"y\"\r\n\"Typeform\"[0..1] # \"Ty\"\r\n\r\nword = \"Typeform\"\r\nword[1..word.length] # \"ypeform\"\r\n```\r\n\r\nPlease upload a ruby file named `lesson1_task1.rb` containing the method `spanish_capitalize`.\r\n\r\n### Task 2: Hipster neighborhoods\r\n\r\nHipsterism has hit the world hard...! And behind every great hipster neighborhood is a great hipster neighborhood name! Have you ever been to \"SoHo\" or \"TriBeCa\" in NYC? :)\r\n\r\nIn this task you will need to write a method whose inputs are a neighborhood abbreviation and its full name and whose output is the abbreviated name but properly capitalized.\r\n\r\nExample:\r\n\r\n- `hipster_spelling('soho', 'south of houston') -> 'SoHo'`\r\n- `hipster_spelling('tribeca', 'triangle below canal street') -> 'TriBeCa'`\r\n\r\nA hipster-neighborhood spelling can be found with the following algorithm:\r\n\r\n1. For each word in the full name\r\n2. Find the longest common prefix with the abbreviation\r\n3. Capitalize the first letter of the longest common prefix\r\n4. Chop off the longest common prefix from the beginning of the abbreivation\r\n5. Repeat with each word and the remaining abbreviation until done\r\n\r\nIf you were to write out the steps for an example, you could imagine a process that looks like this:\r\n\r\n1. ***so***ho, ***so***uth -> \"So\" (longest common prefix is 'so')\r\n2. ~~so~~ho, of -> \"\" (there is no longest common prefix)\r\n3. ~~so~~***ho***, ***ho***uston -> \"Ho\" (longest common prefix is 'ho')\r\n\r\nNote: The ~~strikethrough~~ in the example above indicates that part of the abbreviation is not considered when finding the longest prefix.\r\n\r\n#### Part 1\r\n\r\nWrite a method `longest_common_prefix` that can find the longest common prefix between two words\r\n\r\n```ruby\r\ndef longest_common_prefix(word1, word2)\r\n  # your implementation would go here  \r\nend\r\n```\r\n\r\n#### Part 2\r\n\r\nWrite a method `hipster_spelling` that returns the hipster spelling of a given neighborhood\r\n\r\n```ruby\r\ndef hipster_spelling(abbreviation, full_name)\r\n  # your implementation would go here\r\nend",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}